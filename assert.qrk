{
  (import "list.qrk")

  (let passed 0)
  (let failed 0)
  (let failedDetails (list))

  (let assert:equal (fn (el1 el2) {
    (if (= el1 el2) (set passed (+ passed 1)) {
      (set failed (+ failed 1))
      (push failedDetails (list txt el1 el2))
    })
    (return (list el1 el2))
  }))

  (let it (fn (txt cb) {
    (let started (time:now))

    # Assert response
    (let res (cb))
    (let el1 (index res 0))
    (let el2 (index res 1))

    # Elapsed formatting
    (let elapsed (- (time:now) started))
    /*
      < 100ms : green, good
      > 100ms && < 500ms : yellow, normal
      > 500ms: red, bad
    */
    (let elapsedFormatted (if (< elapsed 100) (green (+ elapsed "ms")) (if (< elapsed 500) (yellow (+ elapsed "ms")) (red (+ elapsed "ms")))))

    # Printing result
    (print "  " (if (= el1 el2) (green "✓ ") (red "✕ ")) txt (+ "(" (+ elapsedFormatted ")")))
    (return none)
  }))

  # Function that help screen formatting
  (let describe (fn (text tests) {
    (print)
    (print (bold (white (+ " " text ":"))))
    (tests)
  }))

  (on:exit (fn () {
    (print)
    (print " " (green (+ "✓ " (+ passed " tests complete"))))
    (print " " (red (+ "✕ " (+ failed " tests fail"))))
    (set passed 0)
    (print)
    # Checking if some tests have failed and then printing them
    (if (> failed 0) {
      (foreach failedDetails (fn (fail) {
        (let failTest (index fail 0))
        (print (+ (+ i 1) ")") (+ failTest ":"))
        (print (gray "  - Expected:") (index fail 1))
        (print (gray "  - Received:") (index fail 2))
      }))
      (throw)
    })
  }))
}